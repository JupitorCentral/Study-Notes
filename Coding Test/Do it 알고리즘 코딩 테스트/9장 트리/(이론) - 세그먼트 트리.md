
## 세크먼트 트리란 ?

배열의 구간에 대한 질의를 효율적으로 처리하기 위한 트리 형태의 자료 구조. 
주로 구간 합, 구간 최소/최대값 등을 빠르게 구할 때 사용됨.
각 노드는 배열의 특정 구간에 대한 정보를 저장하며, 이를 통해 $O(log N)$의 시간 복잡도로 질의를 처리할 수 있습니다.

### 세그먼트 트리의 종류 

1. 구간 합
2. 최대
3. 최소

## 만드는 과정

1. 트리 초기화

샘플 데이터 : {5, 8, 4, 3, 7, 2, 1, 6}

### 트리 배열의 크기

데이터 n 개에 대해서, $2^k >= n$ 이 되는 k 중 최솟값을 x 라고 하면 <br>
세그먼트 트리의 크기는 $2^{x+1}$ 로 잡으면 된다. <br>
그 후 데이터의 시작 위치는 $2^{k}$ 부터 insert 해주면 된다.

> 여기서 헷갈릴 수 있는게, 배열 자체는 index 가 0 부터 시작한다. <br>
하지만 1-index 시스템을 사용하므로 실질적으로 array 의 크기는 16이지만 <br>
index 0 은 사용하지 않으므로 1~15 까지 쓰며, index 계산을 1-indexed array 로 쓰게 된다. <br><br>
그러니까 최상위 노드의 인덱스는 1 이고 <br>
인덱스 i 에 대해서 왼쪽 자식노드의 인덱스 : 2i, 오른쪽 자식노드의 인덱스 : 2i + 1 이 된다.

위 샘플 데이터의 크기는 8 이므로 k = 3, <br>
따라서 세그먼트 트리의 크기는 16.

### 1. 초기화

1. 구간합

안쓰거나 비어있는 index 는 0으로 초기화
> 예를들어, 샘플 데이터가 {5, 8, 4, 3, 7} 일 경우에도 k = 3 이 되며, <br>
인덱스 8 ~ 12 자리에 샘플데이터가 자리하게 된다. <br>
이때 인덱스 13~15 의 값은 0으로 초기화한다.

처음 배열 : [0 (not used), 0, 0, 0, 0, 0, 0, 0, 5,8,4,3,7,2,1,6] <br>
$2^k$ 부터 시작이므로, $2^{k}-1$ 부터 왼쪽으로 (낮은 인덱스로) 초기화 해주면 된다.

처음 : idx = 7 ($2^{3}-1$) <br>
그럼 7 의 자식 노드는 (2 * 7) = 14, (2*7) + 1 = 15 <br>
그럼 tree[7] = tree[14] + tree[15] = 6 + 7 = 13

위 과정을 계속 반복

```
                            [36] (0~7)
                         /              \
               [20] (0~3)               [16] (4~7)
               /       \                 /        \
      [13] (0~1)     [7] (2~3)        [9] (4~5)   [7] (6~7)
       /   \          /   \           /    \       /    \
  [5](0) [8](1)   [4](2) [3](3)  [7](4)  [2](5)  [1](6) [6](7)
```

세그먼트 트리는 1차원 배열로 표현된다.

초기 배열


| 인덱스 | 0 | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15 |
| -----| -----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----| -----| -----|
| 값   | 0 |36  | 20  | 16  | 13  | 7   | 9   | 7   | 5   | 8   | 4   | 3   | 7   | 2   | 1   | 6   |
| 구간  | 0 | 0~7 | 0~3 | 4~7 | 0~1 | 2~3 | 4~5 | 6~7 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |

그러니까 상위노드는 하위 리프 노드의 모든 값을 더한 값이 된다.

2. 최대

구간합일땐 $tree[i] = tree[2i] + tree[2i +1]$ 이었다면, <br>
최대일때는 $tree[i] = max(tree[2i] + tree[2i + 1]) 이 된다. <br>
최소일때는 $tree[i] = min(tree[2i] + tree[2i + 1]).

| 인덱스 | 0 | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15 |
| -----| -----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----| -----| -----|
| 값   | 0 | 8  | 8  | 7  | 8  | 4   | 7   | 6   | 5   | 8   | 4   | 3   | 7   | 2   | 1   | 6   |
| 구간  | 0 | 0~7 | 0~3 | 4~7 | 0~1 | 2~3 | 4~5 | 6~7 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |


3. 최소

| 인덱스 | 0 | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15 |
| -----| -----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----| -----| -----|
| 값   | 0 | 1  | 3  | 1  | 5  | 3   | 2   | 1   | 5   | 8   | 4   | 3   | 7   | 2   | 1   | 6   |
| 구간  | 0 | 0~7 | 0~3 | 4~7 | 0~1 | 2~3 | 4~5 | 6~7 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |


### 2. 질의값 구하기

이제 구하고자 하는 내용 대로 세그먼트 트리를 이용하여 구하면 된다.

절차는 이렇다.

1. start_index % 2 == 1 -> select node (otherwise ignore value of that node)
2. end_index % 2 == 0 -> select node (otherwise ignore value of that node)
3. start_index = (start_index + 1) / 2
4. end_index = (end_index - 1) / 2
5. end_index < start_index 가 될때까지 1~4 반복

만약 index 2~6 의 구간합을 구한다고 생각하면 <br>
먼저 질의 인덱스를 세그먼트 트리에 해당하는 인덱스로 변경해주어야 한다. <br>
segment tree index = index + $2^{k} - 1$

예를 들면, 질의 인덱스가 2일때 초기 데이터에서는 2번째 데이터 즉 8을 가리키므로, <br>
이에 해당하는 데이터는 세그먼트 트리의 $2 + 2^{3} - 1$ = 9 번째 인덱스이다. (tree[9] = 8)

start_index = 2 = 9, end_index = 6 = 13

- 첫번쨰 loop <br>
tree[s] = tree[9], tree[9] % 2 == 1 -> 선택 <br>
tree[e] = tree[13], tree[13] % 2 == 1 -> 미 선택 <br>
selected nodes = {9} <br>
s = (s+1) / 2 = 5 <br>
e = (e-1) / 2 = 6 <br>

- 두번째
tree[s] = tree[5], tree[5] % 2 == 1 -> 선택 <br>
tree[e] = tree[6], tree[6] % 2 == 0 -> 선택 <br>
selected nodes = {9, 5, 6} <br>
s = (5 + 1) / 2 = 3 <br>
e = (6 - 1) / 2 = 2  <br>

- 3번쨰
e < s 이므로 종료. <br>
구하고자 하는 2~6의 구간합 : tree[9] + tree[5] + tree[6] = 8 + 7 + 9 = 24 <br>
= ( 8 + 4 + 3 + 7 )
 


### 3. 데이터 업데이트 하기

만약 원본 데이터가 변경되면, 이에 따라 segment tree 도 업데이트 해주어야 한다.

